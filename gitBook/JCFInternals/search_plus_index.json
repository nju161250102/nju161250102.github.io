{"./":{"url":"./","title":"简介","keywords":"","body":"Java集合框架(Java Collections Framework)介绍 整理自：CarpenterLee/JCFInternals，如需转载请注明原文出处 接口 JCF定义了14种容器接口（collection interfaces），它们的关系如下图所示： Map接口没有继承自Collection接口，因为Map表示关联式容器 Stack的功能已被Deque取代 实现 ImplementationsHash TableResizable ArrayBalanced TreeLinked ListHash Table + Linked ListInterfacesSetHashSetTreeSetLinkedHashSetListArrayListLinkedListDequeArrayDequeLinkedListMapHashMapTreeMapLinkedHashMap Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-26 20:59:57 "},"OverView/":{"url":"OverView/","title":"概述","keywords":"","body":"概览 容器，就是可以容纳其他Java对象的对象。Java Collections Framework（JCF）为Java开发者提供了通用的容器，其始于JDK 1.2，优点是： 降低编程难度 提高程序性能 提高API间的互操作性 降低学习难度 降低设计和实现相关API的难度 增加程序的重用性 Java容器里只能放对象，对于基本类型（int, long, float, double等），需要将其包装成对象类型后（Integer, Long, Float, Double等）才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。 Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-26 21:00:08 "},"OverView/泛型.html":{"url":"OverView/泛型.html","title":"泛型","keywords":"","body":"泛型 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。泛型的类型替换在编译阶段完成，只在编译阶段有效。 泛型类与泛型方法 // 定义一个泛型类 public class ExampleClass { private T key; public setKey(T key) { this.key = key; } public T getKey() { // getKey的返回值类型为T return this.key; } …… } 泛型接口 // 定义一个泛型接口 public interface ExampleInterface { public T next(); } 实现泛型接口的类，未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。 // 泛型接口中为 class ExampleImpl implements ExampleInterface{ @Override public T next() { return null; } } 实现泛型接口的类，传入泛型实参时，所有使用泛型的地方都要替换成传入的实参类型。 // 泛型接口中为 public class FruitGenerator implements Generator { @Override public String next() { return \"\"; } } 泛型方法 public与返回值之间的\\必不可少，这表明这是一个泛型方法，并且声明了泛型。只有声明了\\的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 public K ExampleMethod(Class class) { …… } 类型通配符 可以把？看成所有类型的父类。避免了子类无法被转换成父类 Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-26 23:10:52 "},"OverView/迭代器.html":{"url":"OverView/迭代器.html","title":"迭代器","keywords":"","body":"迭代器 JCF的迭代器（Iterator）为我们提供了遍历容器中元素的方法。只有容器本身清楚容器里元素的组织方式，因此迭代器只能通过容器本身得到。每个容器都会通过内部类的形式实现自己的迭代器，因此不能new一个迭代器出来。 // 原始写法 Iterator it = list.iterator();//得到迭代器 while(it.hasNext()){ String item = it.next();//访问元素 } // 增强for循环写法 for(String item : list){//enhanced for statement …… } Iterable 接口： public interface Iterable; Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-26 23:29:42 "},"ArrayList/":{"url":"ArrayList/","title":"ArrayList","keywords":"","body":"总体介绍 ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。 Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-26 18:55:52 "}}