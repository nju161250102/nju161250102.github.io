{"./":{"url":"./","title":"简介","keywords":"","body":"Java集合框架(Java Collections Framework)介绍 整理自：CarpenterLee/JCFInternals，如需转载请注明原文出处 接口 JCF定义了14种容器接口（collection interfaces），它们的关系如下图所示： Map接口没有继承自Collection接口，因为Map表示关联式容器 Stack的功能已被Deque取代 实现 ImplementationsHash TableResizable ArrayBalanced TreeLinked ListHash Table + Linked ListInterfacesSetHashSetTreeSetLinkedHashSetListArrayListLinkedListDequeArrayDequeLinkedListMapHashMapTreeMapLinkedHashMap Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-26 20:59:57 "},"OverView/":{"url":"OverView/","title":"概述","keywords":"","body":"概览 容器，就是可以容纳其他Java对象的对象。Java Collections Framework（JCF）为Java开发者提供了通用的容器，其始于JDK 1.2，优点是： 降低编程难度 提高程序性能 提高API间的互操作性 降低学习难度 降低设计和实现相关API的难度 增加程序的重用性 Java容器里只能放对象，对于基本类型（int, long, float, double等），需要将其包装成对象类型后（Integer, Long, Float, Double等）才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。 Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-26 21:00:08 "},"OverView/泛型.html":{"url":"OverView/泛型.html","title":"泛型","keywords":"","body":"泛型 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。泛型的类型替换在编译阶段完成，只在编译阶段有效。 泛型类与泛型方法 // 定义一个泛型类 public class ExampleClass { private T key; public setKey(T key) { this.key = key; } public T getKey() { // getKey的返回值类型为T return this.key; } …… } 泛型接口 // 定义一个泛型接口 public interface ExampleInterface { public T next(); } 实现泛型接口的类，未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。 // 泛型接口中为 class ExampleImpl implements ExampleInterface{ @Override public T next() { return null; } } 实现泛型接口的类，传入泛型实参时，所有使用泛型的地方都要替换成传入的实参类型。 // 泛型接口中为 public class FruitGenerator implements Generator { @Override public String next() { return \"\"; } } 泛型方法 public与返回值之间的\\必不可少，这表明这是一个泛型方法，并且声明了泛型。只有声明了\\的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 public K ExampleMethod(Class class) { …… } 类型通配符 可以把？看成所有类型的父类。避免了子类无法被转换成父类 Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-26 23:10:52 "},"OverView/迭代器.html":{"url":"OverView/迭代器.html","title":"迭代器","keywords":"","body":"迭代器 JCF的迭代器（Iterator）为我们提供了遍历容器中元素的方法。只有容器本身清楚容器里元素的组织方式，因此迭代器只能通过容器本身得到。每个容器都会通过内部类的形式实现自己的迭代器，因此不能new一个迭代器出来。 // 原始写法 Iterator it = list.iterator();//得到迭代器 while(it.hasNext()){ String item = it.next();//访问元素 } // 增强for循环写法 for(String item : list){//enhanced for statement …… } Iterable 接口： public interface Iterable; Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-26 23:29:42 "},"ArrayList/":{"url":"ArrayList/","title":"ArrayList","keywords":"","body":"总体介绍 内部实现 ArrayList 实现了 List 接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。每个 ArrayList 都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。 size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。 多线程 该类未实现同步，如果多个线程同时访问 ArrayList 实例，并且至少有一个线程在结构上修改了列表，则必须在外部进行同步。（结构修改是指添加或删除一个或多个元素的操作） List list = Collections.synchronizedList(new ArrayList(...)); 迭代器 迭代器由iterator和listIterator方法返回。如果创建迭代器之后，未通过迭代器自己的remove或add方法，对列表进行了结构上的修改，迭代器将抛出ConcurrentModificationException。迭代器的这一特性在并发修改时无法得到保证。 Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-27 09:39:31 "},"ArrayList/构造方法.html":{"url":"ArrayList/构造方法.html","title":"构造方法","keywords":"","body":"构造方法 指定初始大小：public ArrayList(int initialCapacity) { if (initialCapacity > 0) { // 初始容量大于0，初始化为Object数组，注意elementData存放的不是泛型类型 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 初始容量为0，初始化为默认空数组 this.elementData = EMPTY_ELEMENTDATA; } else { // 否则抛出异常 throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } 空白构造方法：public ArrayList() { // DEFAULTCAPACITY_EMPTY_ELEMENTDATA = []; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 从另一个集合类构造：public ArrayList(Collection c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray 可能不会返回Object[] if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // 替换为空数组 this.elementData = EMPTY_ELEMENTDATA; } } 涉及的方法 Arrays.copyOf// 使用指定的长度复制数组内容，Class表明可以将子类数组复制为父类数组 public static T[] copyOf(U[] original, int newLength, Class newType) { @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } Collection.toArray// 返回集合中所有元素的数组，如果迭代器保证顺序，则数组也必须按照相同顺序返回 Object[] toArray(); Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-27 11:29:47 "},"ArrayList/方法剖析.html":{"url":"ArrayList/方法剖析.html","title":"方法剖析","keywords":"","body":"常用方法剖析 set & get 对数组指定位置赋值。 public E set(int index, E element) { rangeCheck(index); // 范围检查 E oldValue = elementData(index); /** * elementData() 用于强制转换Object[]内元素为正确类型 * E elementData(int index) { * return (E) elementData[index]; * } */ elementData[index] = element; // 赋值到指定位置，复制的仅仅是引用 return oldValue; // 返回旧值 } get()方法注意由于底层数组是Object[]，得到元素后需要进行类型转换。 public E get(int index) { rangeCheck(index); // 范围检查 return elementData(index); } add 向数组末尾增加元素： public boolean add(E e) { ensureCapacityInternal(size + 1); // 可能扩容 elementData[size++] = e; return true; } 向数组中某一位置插入元素： public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // 可能扩容 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 数组向后移动 elementData[index] = element; // 插入元素 size++; } 扩容 扩容操作最终由grow完成： private void grow(int minCapacity) { int oldCapacity = elementData.length; // 新的数组容量 int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); // 复制到扩容后的数组 elementData = Arrays.copyOf(elementData, newCapacity); } 由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。 remove remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。 public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; //清除该位置的引用，让GC起作用 return oldValue; } 关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。 Qian®It’s not a bug – it’s an undocumented feature.Copyright © Qian all right reserved, powered by aleen42修改于 2018-12-27 14:34:40 "}}