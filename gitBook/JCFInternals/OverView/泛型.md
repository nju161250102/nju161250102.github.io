# 泛型

泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。泛型的类型替换在编译阶段完成，只在编译阶段有效。

## 泛型类与泛型方法
```java
// 定义一个泛型类
public class ExampleClass<T> {
    private T key;
    
    public setKey(T key) {
        this.key = key;
    }
    
    public T getKey() { // getKey的返回值类型为T
        return this.key;
    }
	……
}
```

## 泛型接口
```java
// 定义一个泛型接口
public interface ExampleInterface<T> {
    public T next();
}
```
实现泛型接口的类，未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。
```java
// 泛型接口中为<T>
class ExampleImpl<T> implements ExampleInterface<T>{
    @Override
    public T next() {
        return null;
    }
}
```
实现泛型接口的类，传入泛型实参时，所有使用泛型的地方都要替换成传入的实参类型。
```java
// 泛型接口中为<具体类>
public class FruitGenerator implements Generator<String> {
    @Override 
    public String next() { 
        return ""; 
    } 
}
```

## 泛型方法
public与返回值之间的\<T>必不可少，这表明这是一个泛型方法，并且声明了泛型。只有声明了\<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
```java
public <T,K> K ExampleMethod(Class<T> class) {
    ……
}
```

## 类型通配符
可以把？看成所有类型的父类。避免了子类无法被转换成父类